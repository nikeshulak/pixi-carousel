{"version":3,"sources":["Circle.js","Director.js","Slide.js","SlideManagerBase.js","SlideManager.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"pixi-carousel.js","sourcesContent":["function Circle(options) {\n  options = options || {};\n  this.radius = options.radius || 5;\n  this.position = options.position || {x: 0, y: 0};\n  this.color =  options.color || 0x000000;\n  this.color_active =  options.color_active || 0x000000;\n  this.fillAlpha =  options.fillAlpha || 0.9;\n  this.fillAlpha_active =  options.fillAlpha_active || 0.5;\n}","function Director(width, height, options) {\n  this.now;\n  this.dt;\n  this.then = Date.now();\n  \n  options = options || {};\n  this.WIDTH = width || 640;\n  this.HEIGHT = height || 480;\n}\n\nDirector.prototype.animate = function() {\n  // don't override!\n  this.now = Date.now();\n  this.dt = this.now - this.then;\n\n  requestAnimationFrame(this.animate.bind(this));\n  this.updateAndRender(this.dt);\n  \n  this.then = this.now;\n};\n\nDirector.prototype.updateAndRender = function(dt) {\n  // must override!\n  this.update(dt);\n  this.render();\n};\n\nDirector.prototype.update = function(dt) {\n  // must override!\n};\n\nDirector.prototype.render = function() {\n  // must override!\n};\n\n","function Slide(width, height, img_src, img) {\n  this.width = width || 640;\n  this.height = height || 480;\n  this.width_cached = this.width;\n  this.height_cached = this.height;\n  this.height = height;\n  this.img_src = img_src;\n  this.img = img || null;\n\n  this.anchor = {x: 0.5, y: 0.5};\n  this.position = {x: 0, y: 0};\n  this.cached_position = {x: 0, y: 0};\n  this.temp_position = {x: 0, y: 0};\n}\n\nSlide.prototype.cache_position = function() {\n  this.cached_position.x = this.position.x;\n  this.cached_position.y = this.position.y;\n};\n\nSlide.prototype.restoreCachedPosition = function() {\n  this.position.x = this.cached_position.x;\n  this.position.y = this.cached_position.y;\n};\n\nSlide.prototype.saveTempPosition = function() {\n  this.temp_position.x = this.position.x;\n  this.temp_position.y = this.position.y;\n};\n\nSlide.prototype.cache_size = function() {\n  this.width_cached = this.width;\n  this.height_cached = this.height;\n};\n","SlideManagerBase.prototype = Object.create(Director.prototype);\n\nfunction SlideManagerBase(width, height, options) {\n  Director.call(this, width, height, options);\n  options = options || {};\n  this.SLIDE_DURATION = options.slide_duration || 300;\n  this.SLIDE_PERCENT_Y = options.slide_percent_y || 0.5;\n  // SLIDE_PERCENT_Y only effect when scale is CROP\n  this.CIRCLE_COLOR = options.indicator_color || 0x000000;\n  this.CIRCLE_COLOR_ACTIVE = options.indicator_color_active || 0x000000;\n  this.CIRCLE_FILLALPHA = options.indicator_fillAlpha || 0.9;\n  this.CIRCLE_FILLALPHA_ACTIVE = options.indicator_fillAlpha_active || 0.5;\n  this.CIRCLE_RADIUS = options.indicator_radius || 8;\n  this.CIRCLE_MARGIN = options.indicator_margin || 25;\n  this.CIRCLE_PERCENT_Y = options.indicator_percent_y || 0.9;\n  this.BKG_COLOR = options.bkg_color || 0x000000;\n  this.scale = options.scale || this.SCALES.FIT;\n\n  this.has_indicators = options.has_indicators || true;\n  this.speed = this.WIDTH / this.SLIDE_DURATION;\n  this.is_accelerated = options.is_accelerated || false;\n  this.initial_speed = this.is_accelerated ? (2 * this.WIDTH / this.SLIDE_DURATION) : this.speed;\n  this.acceleration = this.is_accelerated ? (this.initial_speed / this.SLIDE_DURATION) : 0;\n\n  this.is_auto_slide = options.is_auto_slide || false;\n  this.interval = options.interval || 1000;\n\n  this.zoom_ratio = options.zoom_ratio || 2;\n  this.zoom_interval = options.zoom_interval || 300;\n\n  this.states = {\n    still: {duration: null},\n    sliding_left: {duration: this.SLIDE_DURATION},\n    sliding_right: {duration: this.SLIDE_DURATION},\n    zoomming_in: {},\n    zoomming_out: {},\n    inspecting: {}\n  };\n  this.state = this.states.still;\n  this.state_time = 0;\n  this.slides = [];\n  this.slide_count = 0;\n  this.indicators = [];\n\n  this.is_position_adjusted = false;\n\n  this.onInit = options.onInit || null;\n  this.onSlideBegin = options.onSlideBegin || null;\n  this.onSlideEnd = options.onSlideEnd || null;\n}\n\nSlideManagerBase.prototype.getZoomedLength = function (length_cached, state_time) {\n  return 0.37 * length_cached * Math.log(state_time + (1 + Math.sqrt(1 + 4 * this.zoom_interval)) / 2);\n};\n\nSlideManagerBase.prototype.zoomIn = function () {\n  if (this.state !== this.states.still) {\n    return;\n  }\n  this.state = this.states.zoomming_in;\n  this.state_time = 0;\n  var slide = this.getActiveSlide();\n  if (slide) {\n    slide.cache_position();\n    slide.saveTempPosition();\n    slide.cache_size();\n  }\n};\n\nSlideManagerBase.prototype.zoomOut = function () {\n  if (this.state !== this.states.inspecting) {\n    return;\n  }\n  var slide = this.getActiveSlide();\n  if (slide) {\n    slide.restoreCachedPosition();\n  }\n  this.state = this.states.zoomming_out;\n  this.state_time = 0;\n};\n\nSlideManagerBase.prototype.update = function (dt) {\n  Director.prototype.update.call(this, dt);\n  if (this.slide_count < 2) {\n    return;\n  }\n\n  this.state_time += dt;\n  switch (this.state) {\n    case this.states.still:\n      if (this.is_auto_slide === true && this.state_time > this.interval) {\n        this.slideLeft();\n      }\n      break;\n    case this.states.zoomming_in:\n      if (this.state_time > this.zoom_interval) {\n        this.state = this.states.inspecting;\n        this.state_time = 0;\n      } else {\n        var slide = this.getActiveSlide();\n        slide.width = this.getZoomedLength(slide.width_cached, this.state_time);\n        slide.height = this.getZoomedLength(slide.height_cached, this.state_time);\n      }\n      break;\n    case this.states.zoomming_out:\n      var slide = this.getActiveSlide();\n      if (this.state_time > this.zoom_interval) {\n        this.state = this.states.still;\n        this.state_time = 0;\n        slide.width = slide.width_cached;\n        slide.height = slide.height_cached;\n      } else {\n        slide.width = 3 * slide.width_cached - this.getZoomedLength(slide.width_cached, this.state_time);\n        slide.height = 3 * slide.height_cached - this.getZoomedLength(slide.height_cached, this.state_time);\n      }\n      break;\n    case this.states.inspecting:\n    default:\n      // sliding\n      if (this.state_time > this.state.duration) {\n//      this.is_position_adjusted = false;\n//      this.adjustPosition();\n        // sliding finished\n        if (this.onSlideEnd) {\n          this.onSlideEnd();\n        }\n        var active_slide = this.getActiveSlide();\n        var offset = this.WIDTH / 2 - active_slide.position.x;\n        for (var i = 0; i < this.slide_count; i++) {\n          this.slides[i].position.x += offset;\n        }\n        this.state = this.states.still;\n        this.state_time = this.state_time - this.state.duration;\n        this.adjustCircles();\n      } else {\n        // sliding not finished\n        switch (this.state) {\n          case this.states.sliding_left:\n            this.updateSliding();\n            break;\n          case this.states.sliding_right:\n            this.updateSliding();\n            break;\n          default:\n            break;\n        }\n        this.adjustPosition();\n      }\n      break;\n  }\n};\n\nSlideManagerBase.prototype.updateSliding = function () {\n  var sign = this.state === this.states.sliding_left ? -1 : 1;\n  for (var i = 0; i < this.slide_count; i++) {\n    var delta_s = this.initial_speed * this.state_time - 0.5 * this.acceleration * Math.pow(this.state_time, 2);\n    this.slides[i].position.x = this.slides[i].cached_position.x + sign * delta_s;\n  }\n};\n\nSlideManagerBase.prototype.getSpeed = function () {\n  if (this.state === this.states.still) {\n    return 0;\n  }\n\n  if (this.is_accelerated) {\n    return this.initial_speed - this.acceleration * this.state_time;\n  } else {\n    return this.initial_speed;\n  }\n};\n\nSlideManagerBase.prototype.getActiveSlide = function () {\n  // the nearest slide\n  if (!this.slides.length) {\n    return false;\n  }\n  var slide = this.slides.reduce(function (s1, s2) {\n    return Math.abs(s1.position.x - this.WIDTH / 2) < Math.abs(s2.position.x - this.WIDTH / 2) ? s1 : s2;\n  }.bind(this));\n  return slide;\n};\n\nSlideManagerBase.prototype.getActiveIndex = function () {\n  if (!this.slides.length) {\n    return false;\n  }\n  // the nearest slide\n  return this.slides.indexOf(this.getActiveSlide());\n};\n\nSlideManagerBase.prototype.adjustCircles = function () {\n  var active_index = this.slides.indexOf(this.getActiveSlide());\n  for (var i = 0, len = this.indicators.length; i < len; i++) {\n    this.indicators[i].color = this.CIRCLE_COLOR;\n    this.indicators[i].fillAlpha = this.CIRCLE_FILLALPHA;\n  }\n  this.indicators[active_index].color = this.CIRCLE_COLOR_ACTIVE;\n  this.indicators[active_index].fillAlpha = this.CIRCLE_FILLALPHA_ACTIVE;\n};\n\nSlideManagerBase.prototype.adjustPosition = function () {\n  if (this.is_position_adjusted) {\n    return;\n  }\n  var left_slide = this.slides.reduce(function (s1, s2) {\n    return s1.position.x < s2.position.x ? s1 : s2;\n  }.bind(this));\n  var right_slide = this.slides.reduce(function (s1, s2) {\n    return s1.position.x > s2.position.x ? s1 : s2;\n  }.bind(this));\n  if (this.state === this.states.sliding_left && left_slide.position.x < this.WIDTH / 2 && left_slide !== this.getActiveSlide()) {\n    left_slide.position.x = right_slide.position.x + this.WIDTH;\n    left_slide.cached_position.x = right_slide.cached_position.x + this.WIDTH;\n  } else if (this.state === this.states.sliding_right && right_slide.position.x > this.WIDTH / 2 && right_slide !== this.getActiveSlide()) {\n    right_slide.position.x = left_slide.position.x - this.WIDTH;\n    right_slide.cached_position.x = left_slide.cached_position.x - this.WIDTH;\n  }\n  this.is_position_adjusted = true;\n};\n\nSlideManagerBase.prototype.slideLeft = function () {\n  if (this.state !== this.states.still) {\n    return;\n  }\n  if (this.onSlideBegin) {\n    this.onSlideBegin();\n  }\n  this.is_position_adjusted = false;\n  this.cache_slide_positions();\n  this.state = this.states.sliding_left;\n  this.state_time = 0;\n};\n\nSlideManagerBase.prototype.slideRight = function () {\n  if (this.state !== this.states.still) {\n    return;\n  }\n  if (this.onSlideBegin) {\n    this.onSlideBegin();\n  }\n  this.is_position_adjusted = false;\n  this.cache_slide_positions();\n  this.state = this.states.sliding_right;\n  this.state_time = 0;\n};\n\nSlideManagerBase.prototype.panTo = function (x, y) {\n  if (this.state !== this.states.inspecting) {\n    return;\n  }\n  var slide = this.getActiveSlide();\n  if (slide) {\n    if (x - 0.5 * slide.width >= 0 || x + 0.5 * slide.width <= this.WIDTH) {\n    } else {\n      slide.position.x = x;\n    }\n    if (y - 0.5 * slide.height >= 0 || y + 0.5 * slide.height <= this.HEIGHT) {\n    } else {\n      slide.position.y = y;\n    }\n  }\n};\n\nSlideManagerBase.prototype.startAutoSlide = function (interval) {\n  this.interval = interval || this.interval;\n  this.is_auto_slide = true;\n};\n\nSlideManagerBase.prototype.stopAutoSlide = function () {\n  this.is_auto_slide = false;\n};\n\nSlideManagerBase.prototype.cache_slide_positions = function () {\n  for (var i = 0; i < this.slide_count; i++) {\n    this.slides[i].cache_position();\n  }\n};\n\nSlideManagerBase.prototype.setSlidesAndStart = function (img_srcs, options) {\n  this.setSlides(img_srcs, options);\n  this.init();\n  this.animate();\n};\n\nSlideManagerBase.prototype.setSlides = function (img_srcs, options) {\n  options = options || {};\n  var width = options.width || this.WIDTH;\n  var height = options.height || this.HEIGHT;\n  this.slide_count = img_srcs.length;\n  for (var i = 0; i < this.slide_count; i++) {\n    if (typeof (img_srcs[i]) === 'string') {\n      this.slides.push(new Slide(width, height, img_srcs[i], null));\n    } else {\n      this.slides.push(new Slide(width, height, null, img_srcs[i]));\n    }\n  }\n};\n\nSlideManagerBase.prototype.init = function () {\n  // position slides and indicators\n  var len = this.slide_count;\n  var left_indicator_x = this.WIDTH / 2 - (len - 1) * this.CIRCLE_MARGIN / 2;\n  for (var i = 0; i < len; i++) {\n    var slide = this.slides[i];\n\n//    slide.width = this.WIDTH;\n//    slide.height = this.HEIGHT;\n    slide.anchor.x = 0.5;\n    slide.anchor.y = 0.5;\n    slide.position.x = this.WIDTH / 2 + i * this.WIDTH;\n    slide.position.y = this.HEIGHT * this.SLIDE_PERCENT_Y;\n\n    switch (this.scale) {\n      case this.SCALES.STRETCH:\n        slide.width = this.WIDTH;\n        slide.height = this.HEIGHT;\n        slide.position.y = this.HEIGHT * 0.5;\n      case this.SCALES.FIT:\n        var aspRatio = slide.width / slide.height;\n        if (aspRatio > this.WIDTH / this.HEIGHT) {\n          slide.width = this.WIDTH;\n          slide.height = slide.width / aspRatio;\n        } else {\n          slide.height = this.HEIGHT;\n          slide.width = slide.height * aspRatio;\n        }\n      case this.SCALES.CROP:\n      default:\n    }\n\n    var indicator = new Circle({\n      radius: this.CIRCLE_RADIUS,\n      position: {x: left_indicator_x + this.CIRCLE_MARGIN * i, y: this.HEIGHT * this.CIRCLE_PERCENT_Y},\n      color: i === 0 ? this.CIRCLE_COLOR_ACTIVE : this.CIRCLE_COLOR,\n      fillAlpha: i === 0 ? this.CIRCLE_FILLALPHA_ACTIVE : this.CIRCLE_FILLALPHA,\n    });\n    this.indicators.push(indicator);\n  }\n  if (this.onInit) {\n    this.onInit();\n  }\n};\n\nSlideManagerBase.prototype.SCALES = {\n  CROP: {},\n  STRETCH: {},\n  FIT: {}\n};","SlideManager.prototype = Object.create(SlideManagerBase.prototype);\n\nfunction SlideManager(width, height, options) {\n  SlideManagerBase.call(this, width, height, options);\n  this.textures = [];\n  this.sprites = [];\n  this.graphics = new PIXI.Graphics();\n//  this.stage = new PIXI.Stage(this.BKG_COLOR);   // pixi 2\n  this.stage = new PIXI.Container();\n//  this.renderer = new PIXI.CanvasRenderer(width, height, {view: options.view}, true);\n  this.renderer = PIXI.autoDetectRenderer(width, height, {view: options.view, backgroundColor: this.BKG_COLOR});   // pixi 3\n\n  this.hammertime = new Hammer(options.view);\n  this.hammertime.get('swipe').set({direction: Hammer.DIRECTION_HORIZONTAL});\n  this.hammertime.get('pan').set({direction: Hammer.DIRECTION_HORIZONTAL, threshold: 100});\n}\n\nSlideManager.prototype.render = function () {\n//  SlideManagerBase.prototype.render.call(this);\n  if (this.has_indicators) {\n    this.renderIndicators();\n  }\n  for (var i = 0, len = this.slide_count; i < len; i++) {\n    var sl = this.slides[i];\n    var sp = this.sprites[i];\n    sp.width = sl.width;\n    sp.height = sl.height;\n  }\n  this.renderer.render(this.stage);\n};\n\nSlideManager.prototype.renderIndicators = function () {\n  this.graphics.clear();\n  var len = this.indicators.length;\n  if (len > 1) {\n    for (var i = 0; i < len; i++) {\n      var cir = this.indicators[i];\n      this.graphics.beginFill(cir.color);\n      this.graphics.fillAlpha = cir.fillAlpha;\n      this.graphics.drawCircle(cir.position.x, cir.position.y, cir.radius);\n      this.graphics.endFill();\n    }\n  }\n};\n\nSlideManager.prototype.init = function () {\n  SlideManagerBase.prototype.init.call(this);\n  for (var i = 0, len = this.slide_count; i < len; i++) {\n    var sl = this.slides[i];\n    if (sl.img) {\n      var basetex = new PIXI.BaseTexture(sl.img);\n      var tex = new PIXI.Texture(basetex);\n    } else {\n      var tex = PIXI.Texture.fromImage(sl.img_src);\n    }\n    this.textures.push(tex);\n    var sp = new PIXI.Sprite(tex);\n    sp.width = sl.width;\n    sp.height = sl.height;\n    sp.anchor = sl.anchor;\n    sp.position = sl.position;\n    this.sprites.push(sp);\n    this.stage.addChild(sp);\n\n    if (this.has_indicators) {\n      var cir = this.indicators[i];\n      this.graphics.beginFill(0xFFFFFF);\n      this.graphics.fillAlpha = cir.fillAlpha;\n      this.graphics.drawCircle(cir.position.x, cir.position.y, cir.radius);\n      this.graphics.endFill();\n    }\n    this.stage.addChild(this.graphics);\n  }\n  //this.graphics.lineStyle(0, 0x000000, 1);\n};\n\nSlideManager.prototype.enableSwipe = function () {\n  this.hammertime.on('swipeleft panleft', function (ev) {\n    this.slideLeft();\n  }.bind(this));\n  this.hammertime.on('swiperight panright', function (ev) {\n    this.slideRight();\n  }.bind(this));\n}\n\nSlideManager.prototype.enableZoom = function () {\n  this.hammertime.on('tap', function (ev) {\n    if (this.state === this.states.inspecting) {\n      this.hammertime.get('pan').set({direction: Hammer.DIRECTION_HORIZONTAL, threshold: 100});\n      this.zoomOut();\n    } else {\n      this.hammertime.get('pan').set({direction: Hammer.DIRECTION_ALL, threshold: 1});\n      this.zoomIn();\n    }\n  }.bind(this));\n  this.hammertime.on('pan', function (ev) {\n    var slide = this.getActiveSlide();\n    if (slide) {\n      if (this.state !== this.states.inspecting) {\n        return;\n      }\n      ev.preventDefault();\n      this.panTo(slide.temp_position.x + ev.deltaX, slide.temp_position.y + ev.deltaY);\n    }\n  }.bind(this));\n  this.hammertime.on('panend', function (ev) {\n    var slide = this.getActiveSlide();\n    if (slide) {\n      slide.saveTempPosition();\n    }\n  }.bind(this));\n};\n"],"sourceRoot":"/source/"}